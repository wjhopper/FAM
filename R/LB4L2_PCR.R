#' LBL42 PCR
#'
#' Implementation of the PCR model of LB4L2 experiment
#' @param PCR_model_obj A PCRparams object, as generated by \code{initPCR}
#' @param groups A numeric scalar indicating how many independtn groups to
#' make predictions for
#'
#' @return A list of PCR objects, with as many elements as there are \code{groups}.
#' Each list element holds the PCR objects created for each condition.
#'
#' @import PCR
#' @export
#'
#' @examples
#' model_params <- initPCR(params = list(ER=.6, LR=.2, FR=.1, TR=.15, TV = .05),
#'                    distribution = "beta", nItems = 20, nSims = 1000,
#'                    nFeatures = 100, time = 10)
#' results <- LB4L2_PCR(model_params)
#'
LB4L2_PCR <- function(PCR_model_obj, groups = 1, ...) {

  stopifnot(is.finite(groups) && groups > 0)
  simulations <- vector (mode = "list", length = groups)

  control <- study(PCR_model_obj, nCues = 1, tests_per_cue = 1) %>%
    forget(cue = 1) %>%
    thresh_change() %>%
    cuedRecall(cue = 1, increment = FALSE)

  SC_study <- study(PCR_model_obj, nCues = 2, tests_per_cue = c(1,0)) %>%
    study(cue = 1) %>%
    forget(cue = 1) %>%
    thresh_change() %>%
    cuedRecall(cue = 1, increment = FALSE)

  OC_study <- study(PCR_model_obj, nCues = 2, tests_per_cue = c(1,0)) %>%
    study(cue = 2) %>%
    forget(cue = 1) %>%
    thresh_change() %>%
    cuedRecall(cue = 1, increment = FALSE)

  SC_test <- study(PCR_model_obj, nCues = 2, tests_per_cue = c(2,0)) %>%
    cuedRecall(cue = 1) %>%
    forget(cue = 1) %>%
    thresh_change() %>%
    cuedRecall(cue = 1, increment = FALSE)

  OC_test <- study(PCR_model_obj, nCues = 2, tests_per_cue = c(1,1)) %>%
    cuedRecall(cue = 2) %>%
    forget(cue = 1) %>%
    thresh_change() %>%
    cuedRecall(cue = 1, increment = FALSE)

  simulations[[1]] <- list("SC_test" = SC_test, "SC_study" = SC_study,
                       "OC_test" = OC_test, "OC_study" = OC_study,
                       "control" = control)
  class(simulations[[1]]) <- c("LB4L2_PCR")
  done <- 1
  while (done < groups) {
    x <- update(PCR_model_obj, list(FR = PCR_model_obj$params[[paste0("FR",done+1)]]))
    simulations[done + 1]<- LB4L2_PCR(x, groups = 1)
    class(simulations[[done + 1]]) <- c("LB4L2_PCR", class(simulations))
    done <- done + 1
    if (done == length(simulations)) {
      simulations <- setNames(simulations, paste0("group",1:groups))
    }

  }

  return(simulations)

}

#' @export
#' @importFrom tidyr separate
#' @importFrom tidyr gather
summary.LB4L2_PCR <- function(x, DV = "recalled") {

  IV <- bind_rows(lapply(x, summary), .id = "condition") %>%
    mutate(practice = toupper(substr(practice,1,1)))

  practice_test <- filter(IV, practice == "T", test == 1) %>%
    mutate(sameCue = ifelse(grepl("OC", condition), "no", "yes"))

  final_test <- anti_join(IV,practice_test,
                          by = c("condition","practice","test")) %>%
    group_by(condition) %>%
    mutate(OCpractice = switch(first(condition),
                               OC_test = "T",
                               OC_study = "S",
                               "N")) %>%
    ungroup()

  # Subset all the data from items tested twice.
  SC_test <- x[["SC_test"]]$recalled[[1]]
  SC_joint <- mapply(`&`,
                     list(cor_inc = SC_test[,,1], inc_inc = !SC_test[,,1],
                          cor_cor = SC_test[,,1], inc_cor = !SC_test[,,1]),
                     list(!SC_test[,,2], !SC_test[,,2], SC_test[,,2], SC_test[,,2]))

  OC_tp <- x[["OC_test"]]$recalled$Cue2
  OC_final <- x[["OC_test"]]$recalled$Cue1
  OC_joint <- mapply(`&`,
                    list(cor_inc = OC_tp, inc_inc = !OC_tp,
                         cor_cor = OC_tp, inc_cor = !OC_tp),
                    list(!OC_final, !OC_final, OC_final, OC_final))

  ## Joint Accuracy Results
  SC_joint_acc <- colMeans(SC_joint)
  OC_joint_acc <- colMeans(OC_joint)

  ## Joint RT results
  LU_table <- list(joint_outcome = c(cor_inc = "1_0", inc_inc = "0_0",
                                     cor_cor = "1_1",  inc_cor = "0_1"))
  raw_joint_RT <- list(OC_joint_RT = apply(OC_joint, 2,
                                           function(j) {
                                             sapply(rev(x[['OC_test']]$RT), `[`, j)
                                           }),
                       SC_joint_RT = apply(SC_joint, 2,
                                           function(j) {
                                             apply(x[['SC_test']]$RT$Cue1, 3, `[`,j)
                                           })) %>%
    lapply(function(x) {
      lapply(x, function(y) {
        as.data.frame(`dimnames<-`(y, list(NULL, c("practiceRT", "finalRT"))))
        })
      }) %>%
    lapply(bind_rows, .id = "joint_outcome") %>%
    bind_rows(.id = "condition") %>%
    mutate(condition = ifelse(condition == "SC_joint_RT", "yes", "no"),
           joint_outcome = LU_table$joint_outcome[joint_outcome]) %>%
    rename(sameCue = condition) %>%
    separate(joint_outcome, c("practice", "final")) %>%
    mutate_each('as.numeric', practice,final) %>%
    group_by(sameCue, practice, final) %>%
    summarise(rawRTs = list(matrix(c(practiceRT,finalRT),ncol=2,
                                   dimnames = list(NULL, c("practiceRT", "finalRT"))))
              )

  J <- cbind(as.data.frame(SC_joint_acc),
             as.data.frame(OC_joint_acc)) %>%
    mutate(condition = rownames(.)) %>%
    separate(condition, c("practice", "final")) %>%
    mutate(practice = ifelse(practice == "cor", 1, 0),
           final = ifelse(final == "cor", 1, 0)) %>%
    gather(sameCue, probability, SC_joint_acc, OC_joint_acc) %>%
    mutate(sameCue = ifelse(sameCue == "SC_joint_acc", "yes", "no")) %>%
    left_join(y = raw_joint_RT, by = c("sameCue", "practice", "final")) %>%
    tbl_df()

  # Conditional Accuracy
  SC_CD <- SC_joint_acc[c("cor_cor", "inc_cor")]/abs((c(0,1) - practice_test$accuracy[practice_test$sameCue=="yes"]))
  OC_CD <- OC_joint_acc[c("cor_cor", "inc_cor")]/abs((c(0,1) - practice_test$accuracy[practice_test$sameCue=="no"]))

  CD <- cbind(as.data.frame(SC_CD), as.data.frame(OC_CD)) %>%
    mutate(practice = gsub("_cor", "", rownames(.))) %>%
    gather(sameCue, accuracy, SC_CD, OC_CD) %>%
    mutate(sameCue = ifelse(sameCue == "SC_CD", "yes", "no")) %>%
    mutate(sameCue, practice, accuracy)

  return(list(practice= practice_test, final = final_test,
              conditional = CD, joint = J))
}

#' fitPCR
#'
#' @param PCRparams_obj
#' @param prediction_fcn E.g., LB4L2_PCR
#' @param error_fcn
#' @param ...
#'
#' @return
#'
#' @import PCR
#' @export
#'
#' @examples

fitPCR <- function(free_parameters, PCRparams_obj, prediction_fcn, error_fcn, ...) {

  PCRparams_obj <- update(PCRparams_obj, as.list(free_parameters))
  acc_param_vals <- PCRparams_obj$params[names(PCRparams_obj$params) %in% c("ER","LR","FR","FR2","TR","space","TC")]
  RT_param_vals <- PCRparams_obj$params[c("Tmin", "Tmax", "lambda")]

  if (any(sapply(acc_param_vals, function(x) x <= 0.01 || x >= .99))) {
    return(1000000)
  }

  if (any(sapply(RT_param_vals, function(x) x <= 0))) {
    return(1000000)
  }

  if (RT_param_vals$Tmin > RT_param_vals$Tmax) {
    return(1000000)
  }

  raw <- prediction_fcn(PCRparams_obj, groups = list(...)$group)
  if (length(raw) > 1) {
    simulations <- lapply(raw, summary)
    simulations <- do.call(mapply, c(list(FUN = bind_rows), simulations , list(.id = "group")))
  } else {
    simulations <- summary(raw)
  }

  error <- error_fcn(simulations, ...)
  return(error$error)

}

#' LB4L2_PCR Error Function
#'
#' @param simulations
#' @param observations
#' @param likelihood
#'
#' @return
#'
#' @import PCR
#' @importFrom tidyr gather spread unnest
#' @importFrom ks kde
#' @importFrom whoppeR binomialLL multinomialLL
#' @export
#'
#' @examples
LB4L2_PCR_erf <- function(simulations, observations,
                          likelihood = c("RT","accuracy","all"), ...) {

  likelihood <- match.arg(likelihood,  c("RT","accuracy","all"))
  error <- 0

  simulations$final %<>% mutate(group = ifelse(group == "group1", "immediate", "delay"))
  simulations$joint %<>% mutate(group = ifelse(group == "group1", "immediate", "delay"))

  # grep("^pred_", names(IV), value=TRUE, invert = TRUE)
  IV <- inner_join(rename(observations$final, obs_mean_p = mean_p,
                          obs_mean_RT = mean_RT, obs_RTs = rawRTs),
                   select(simulations$final, group, practice, OCpractice,
                          final_acc = accuracy, pred_mean_p = proportion,
                          pred_mean_RT = medianRT, pred_RTs = rawRTs),
                   by = c("group", "practice", "OCpractice", "final_acc")) %>%
    group_by_(.dots = c("group", "practice", "OCpractice")) %>%
    mutate(p_complete = ifelse(final_acc == 1,
                               mean(pexp(8 - pred_RTs[[which(final_acc==1)]], rate = 1)),
                               NA),
           pred_mean_p = pred_mean_p * p_complete,
           pred_mean_p = replace(pred_mean_p, is.na(pred_mean_p), 1-pred_mean_p[!is.na(pred_mean_p)]))

  ## joint probabilities section ##
  conditional_vars <- grep("*acc$", names(observations$joint), value=TRUE)
  J <- inner_join(rename(observations$joint, obs_joint_p = joint_p,
                         obs_mean_RT = mean_RT, obs_RTs = rawRTs),
                  select(simulations$joint, group, sameCue,
                         practice1acc = practice, final_acc = final,
                         pred_joint_p = probability, pred_RTs = rawRTs),
                     by = c("group","sameCue", conditional_vars))
    mixed <- J %>%
      filter(final_acc != practice1acc) %>%
      rowwise() %>%
      mutate(p_complete =  mean(pexp(8 - pred_RTs[,which(c(practice1acc, final_acc)==1)])))%>%
      select(-contains("RTs"))

    one_one <- J %>%
      filter(final_acc ==1, practice1acc==1) %>%
      rowwise() %>%
      mutate(prac_complete = mean(pexp(8 - pred_RTs[,1])),
             final_complete = mean(pexp(8 - pred_RTs[,2])),
             both_complete = mean(apply(pexp(8 - pred_RTs),1,prod))) %>%
      select(-contains("RTs"))

    J <- Reduce(function(x,y) {
            left_join(x,y, by = c("group", "sameCue", "practice1acc","final_acc",
                            "obs_joint_p", "obs_mean_RT", "subject", "pred_joint_p"))
            },
            list(J, mixed, one_one)) %>%
      mutate(prac_complete = replace(prac_complete,
                                      final_acc == 0 & practice1acc == 1,
                                      p_complete[final_acc == 0 & practice1acc == 1]),
             final_complete = replace(final_complete,
                                      final_acc == 1 & practice1acc == 0,
                                      p_complete[final_acc == 1 & practice1acc == 0]),
             p_complete = NULL)

    J %<>% group_by(group,sameCue) %>%
      do( {
        one_one <- .$practice1acc == 1 & .$final_acc == 1
        one_zero <- .$practice1acc == 1 & .$final_acc == 0
        zero_one <- .$practice1acc == 0 & .$final_acc == 1
        zero_zero <- .$practice1acc == 0 & .$final_acc == 0
        d <- .[,c("group","sameCue","practice1acc","final_acc","obs_joint_p",
                  "obs_mean_RT", "obs_RTs", "subject", "pred_RTs")]
        d$pred_joint_p <- NA
        d$pred_joint_p[zero_zero] <- sum(.$pred_joint_p[zero_zero],
                                         .$pred_joint_p[zero_one] - (.$final_complete[zero_one] * .$pred_joint_p[zero_one]),
                                         .$pred_joint_p[one_zero] - (.$prac_complete[one_zero] * .$pred_joint_p[one_zero]))
        d$pred_joint_p[zero_one] <- sum(.$pred_joint_p[zero_one] * .$final_complete[zero_one],
                                        .$pred_joint_p[one_one] - (.$pred_joint_p[one_one] * .$final_complete[one_one]))
        d$pred_joint_p[one_zero] <- sum(.$pred_joint_p[one_zero] * .$prac_complete[one_zero],
                                        .$pred_joint_p[one_one] - (.$pred_joint_p[one_one] * .$prac_complete[one_one]))
        d$pred_joint_p[one_one] <- .$pred_joint_p[one_one] * .$both_complete[one_one]
        return(d)
      } )


  # This finds the probability that each RT from the [correct, correct] condition
  # completes in 8 seconds. Then it multiplies those two together for the joint probability
  # that they both complete in less than 8 seconds. Those probabilities are then averaged.


  if (likelihood %in% c("all","accuracy")) {

    IV_acc_lik <- IV %>%
      filter(final_acc ==1, (practice != "T" & OCpractice != "T")) %>%
      with(binomialLL(obs = obs_mean_p, pred = pred_mean_p, N = 20))

    J_acc_lik <- J %>%
      filter(!is.na(pred_joint_p)) %>%
      mutate(pred = replace(pred_joint_p, pred_joint_p==0, .Machine$double.xmin)) %>%
      with(multinomialLL(obs_joint_p, pred_joint_p, N = 20))

    error <- error + IV_acc_lik + multinomial_lik
  }

  if (likelihood %in% c("all","RT")) {

    IV_RT_lik <- IV %>%
      filter(final_acc ==1, (practice != "T" & OCpractice != "T")) %>%
      rowwise() %>%
      mutate(lik = list(sapply(obs_RTs,
                               function(x,y) { sum(dexp(Filter(function(z) {z>=0}, x-y))) },
                               y=pred_RTs)))
    J_RT_lik <- J %>%
      rowwise() %>%
      filter(!is.null(obs_RTs)) %>%
      mutate(lik = list(apply(obs_RTs, 1,
                              function(x,y) {
                                a <- x-y
                                a <- a[a[,1]>=0 & a[,2]>=0,]
                                sum(apply(a, 1, function(z) prod(dexp(z, rate =1))))
                              },
                              y=pred_RTs)))
    error <- error + sum(unlist(IV_RT_lik$lik)) + sum(unlist(J_RT_lik$lik))
  }
  return(list(error = error))
}

#' @export
#'
combine <- function(obj, practice = NA, final = NA, conditional = NA, joint = NA) {

}
